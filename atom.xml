<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coin It Yourself</title>
  
  
  <link href="https://coiniy2024.github.io/atom.xml" rel="self"/>
  
  <link href="https://coiniy2024.github.io/"/>
  <updated>2024-06-03T14:42:35.115Z</updated>
  <id>https://coiniy2024.github.io/</id>
  
  <author>
    <name>Bruce</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>比特币开发入门指南</title>
    <link href="https://coiniy2024.github.io/post/0.html"/>
    <id>https://coiniy2024.github.io/post/0.html</id>
    <published>2024-06-03T13:41:51.591Z</published>
    <updated>2024-06-03T14:42:35.115Z</updated>
    
    <content type="html"><![CDATA[<p>了解了，<code>bitcoinjs-lib</code> 的 6.1.5 版本已经移除了 <code>TransactionBuilder</code>。我们将使用 <code>Psbt</code> (Partially Signed Bitcoin Transactions) 来创建交易。这是一种更现代和灵活的方法。下面是更新后的指南：</p><h1 id="比特币开发入门指南"><a href="#比特币开发入门指南" class="headerlink" title="比特币开发入门指南"></a>比特币开发入门指南</h1><p>本文将介绍如何使用 <code>bitcoinjs-lib</code> 的 6.1.5 版本进行比特币开发。从开发环境的搭建到构建交易。我们将使用 <code>remix.run</code> 创建工程，并使用 TypeScript 搭建开发环境。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">开发环境搭建</a></li><li><a href="#%E5%AE%89%E8%A3%85-bitcoinjs-lib">安装 bitcoinjs-lib</a></li><li><a href="#%E5%88%9B%E5%BB%BA%E6%AF%94%E7%89%B9%E5%B8%81%E5%9C%B0%E5%9D%80">创建比特币地址</a></li><li><a href="#%E6%9E%84%E5%BB%BA%E6%AF%94%E7%89%B9%E5%B8%81%E4%BA%A4%E6%98%93">构建比特币交易</a></li><li><a href="#%E9%85%8D%E7%BD%AE%E5%89%8D%E7%AB%AF%E8%B0%83%E7%94%A8-api">配置前端调用 API</a></li><li><a href="#%E5%90%AF%E5%8A%A8%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">启动开发环境</a></li></ol><h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p>首先，我们需要搭建开发环境。以下是使用 <code>remix.run</code> 创建工程的步骤。</p><h3 id="安装-Node-js-和-npm"><a href="#安装-Node-js-和-npm" class="headerlink" title="安装 Node.js 和 npm"></a>安装 Node.js 和 npm</h3><p>确保你已经安装了 Node.js 和 npm。如果没有安装，可以从 <a href="https://nodejs.org/">Node.js 官网</a> 下载并安装。</p><h3 id="创建-Remix-项目"><a href="#创建-Remix-项目" class="headerlink" title="创建 Remix 项目"></a>创建 Remix 项目</h3><p>打开终端并运行以下命令来创建一个新的 Remix 项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-remix@latest my-bitcoin-project</span><br></pre></td></tr></table></figure><p>执行上述命令会输出以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Need to install the following packages:</span><br><span class="line">create-remix@2.9.2</span><br><span class="line">Ok to proceed? (y) y</span><br><span class="line">npm WARN deprecated inflight@1.0.6: This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.</span><br><span class="line">npm WARN deprecated glob@7.2.3: Glob versions prior to v9 are no longer supported</span><br><span class="line"></span><br><span class="line"> remix   v2.9.2 💿 Let&#x27;s build a better website...</span><br><span class="line">      ◼  Directory: Using my-bitcoin-project as project directory</span><br><span class="line"></span><br><span class="line">      ◼  Using basic template See https://remix.run/guides/templates for more</span><br><span class="line">      ✔  Template copied</span><br><span class="line"></span><br><span class="line">   git   Initialize a new git repository?</span><br><span class="line">         Yes</span><br><span class="line"></span><br><span class="line">  deps   Install dependencies with npm?</span><br><span class="line">         Yes</span><br><span class="line"></span><br><span class="line">      ✔  Dependencies installed</span><br><span class="line"></span><br><span class="line">      ✔  Git initialized</span><br><span class="line"></span><br><span class="line">  done   That&#x27;s it!</span><br><span class="line"></span><br><span class="line">         Enter your project directory using cd ./my-bitcoin-project</span><br><span class="line">         Check out README.md for development and deploy instructions.</span><br><span class="line"></span><br><span class="line">         Join the community at https://rmx.as/discord</span><br></pre></td></tr></table></figure><h2 id="安装-bitcoinjs-lib"><a href="#安装-bitcoinjs-lib" class="headerlink" title="安装 bitcoinjs-lib"></a>安装 bitcoinjs-lib</h2><p>在你的项目目录下，运行以下命令来安装 <code>bitcoinjs-lib</code> 库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install bitcoinjs-lib@6.1.5</span><br><span class="line">npm install tiny-secp256k1</span><br><span class="line">npm install bip32</span><br></pre></td></tr></table></figure><h2 id="创建比特币地址"><a href="#创建比特币地址" class="headerlink" title="创建比特币地址"></a>创建比特币地址</h2><p>下面我们将演示如何使用 <code>bitcoinjs-lib</code> 创建一个比特币地址。</p><p>在项目的 <code>app</code> 目录下创建一个新的 TypeScript 文件，例如 <code>generateAddress.ts</code>，并添加以下代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bitcoin <span class="keyword">from</span> <span class="string">&#x27;bitcoinjs-lib&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ecc <span class="keyword">from</span> <span class="string">&#x27;tiny-secp256k1&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BIP32Factory</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;bip32&#x27;</span>;</span><br><span class="line"></span><br><span class="line">bitcoin.<span class="title function_">initEccLib</span>(ecc);</span><br><span class="line"><span class="keyword">const</span> bip32 = <span class="title class_">BIP32Factory</span>(ecc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">generateBitcoinAddress</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> keyPair = bip32.<span class="title function_">fromSeed</span>(<span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">32</span>)); <span class="comment">// 使用随机生成的种子</span></span><br><span class="line">  <span class="keyword">const</span> &#123; address &#125; = bitcoin.<span class="property">payments</span>.<span class="title function_">p2pkh</span>(&#123; <span class="attr">pubkey</span>: keyPair.<span class="property">publicKey</span> &#125;);</span><br><span class="line">  <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> address = <span class="title function_">generateBitcoinAddress</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Generated Bitcoin Address: <span class="subst">$&#123;address&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>你可以将上述代码集成到 Web 服务中，具体方式在后续步骤中会说明。</p><h2 id="构建比特币交易"><a href="#构建比特币交易" class="headerlink" title="构建比特币交易"></a>构建比特币交易</h2><p>接下来，我们将演示如何使用 <code>bitcoinjs-lib</code> 构建一个比特币交易。</p><p>在 <code>app</code> 目录下创建一个新的 TypeScript 文件，例如 <code>createTransaction.ts</code>，并添加以下代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bitcoin <span class="keyword">from</span> <span class="string">&#x27;bitcoinjs-lib&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ecc <span class="keyword">from</span> <span class="string">&#x27;tiny-secp256k1&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BIP32Factory</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;bip32&#x27;</span>;</span><br><span class="line"></span><br><span class="line">bitcoin.<span class="title function_">initEccLib</span>(ecc);</span><br><span class="line"><span class="keyword">const</span> bip32 = <span class="title class_">BIP32Factory</span>(ecc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createTransaction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> keyPair = bip32.<span class="title function_">fromSeed</span>(<span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">32</span>)); <span class="comment">// 使用随机生成的种子</span></span><br><span class="line">  <span class="keyword">const</span> &#123; address &#125; = bitcoin.<span class="property">payments</span>.<span class="title function_">p2pkh</span>(&#123; <span class="attr">pubkey</span>: keyPair.<span class="property">publicKey</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 假设我们有一个未花费交易输出 (UTXO)</span></span><br><span class="line">  <span class="keyword">const</span> psbt = <span class="keyword">new</span> bitcoin.<span class="title class_">Psbt</span>();</span><br><span class="line">  psbt.<span class="title function_">addInput</span>(&#123;</span><br><span class="line">    <span class="attr">hash</span>: <span class="string">&#x27;previousTxId&#x27;</span>, <span class="comment">// previousTxId 为前一个交易的 ID</span></span><br><span class="line">    <span class="attr">index</span>: <span class="number">0</span>, <span class="comment">// 输出索引</span></span><br><span class="line">    <span class="attr">witnessUtxo</span>: &#123;</span><br><span class="line">      <span class="attr">script</span>: <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;76a914&#x27;</span> + bitcoin.<span class="property">crypto</span>.<span class="title function_">hash160</span>(keyPair.<span class="property">publicKey</span>).<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>) + <span class="string">&#x27;88ac&#x27;</span>, <span class="string">&#x27;hex&#x27;</span>),</span><br><span class="line">      <span class="attr">value</span>: <span class="number">100000</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  psbt.<span class="title function_">addOutput</span>(&#123;</span><br><span class="line">    address,</span><br><span class="line">    <span class="attr">value</span>: <span class="number">90000</span>, <span class="comment">// 发送金额 (扣除手续费)</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  psbt.<span class="title function_">signInput</span>(<span class="number">0</span>, keyPair);</span><br><span class="line">  psbt.<span class="title function_">finalizeAllInputs</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tx = psbt.<span class="title function_">extractTransaction</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Transaction Hex: <span class="subst">$&#123;tx.toHex()&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createTransaction</span>();</span><br></pre></td></tr></table></figure><h2 id="配置前端调用-API"><a href="#配置前端调用-API" class="headerlink" title="配置前端调用 API"></a>配置前端调用 API</h2><p>在 <code>app/routes</code> 目录下创建一个新的 API 路由文件，例如 <code>app/routes/api/bitcoin.tsx</code>。这个文件将包含生成比特币地址和构建比特币交易的逻辑。</p><h3 id="生成比特币地址-API"><a href="#生成比特币地址-API" class="headerlink" title="生成比特币地址 API"></a>生成比特币地址 API</h3><p>在 <code>app/routes/api/bitcoin.tsx</code> 中添加以下代码来创建一个生成比特币地址的 API 接口：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; json &#125; <span class="keyword">from</span> <span class="string">&quot;@remix-run/node&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">LoaderFunction</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@remix-run/node&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bitcoin <span class="keyword">from</span> <span class="string">&#x27;bitcoinjs-lib&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ecc <span class="keyword">from</span> <span class="string">&#x27;tiny-secp256k1&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BIP32Factory</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;bip32&#x27;</span>;</span><br><span class="line"></span><br><span class="line">bitcoin.<span class="title function_">initEccLib</span>(ecc);</span><br><span class="line"><span class="keyword">const</span> bip32 = <span class="title class_">BIP32Factory</span>(ecc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">loader</span>: <span class="title class_">LoaderFunction</span> = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> keyPair = bip32.<span class="title function_">fromSeed</span>(<span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">32</span>)); <span class="comment">// 使用随机生成的种子</span></span><br><span class="line">  <span class="keyword">const</span> &#123; address &#125; = bitcoin.<span class="property">payments</span>.<span class="title function_">p2pkh</span>(&#123; <span class="attr">pubkey</span>: keyPair.<span class="property">publicKey</span> &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">json</span>(&#123; address &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">BitcoinApi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建比特币交易-API"><a href="#构建比特币交易-API" class="headerlink" title="构建比特币交易 API"></a>构建比特币交易 API</h3><p>在同一个文件中添加一个 POST 请求处理器来构建比特币交易：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ActionFunction</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@remix-run/node&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">action</span>: <span class="title class_">ActionFunction</span> = <span class="keyword">async</span> (&#123; request &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; previousTxId, vout, amount, toAddress &#125; = <span class="keyword">await</span> request.<span class="title function_">json</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keyPair = bip32.<span class="title function_">fromSeed</span>(<span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">32</span>)); <span class="comment">// 使用随机生成的种子</span></span><br><span class="line">  <span class="keyword">const</span> psbt = <span class="keyword">new</span> bitcoin.<span class="title class_">Psbt</span>();</span><br><span class="line">  psbt.<span class="title function_">addInput</span>(&#123;</span><br><span class="line">    <span class="attr">hash</span>: previousTxId,</span><br><span class="line">    <span class="attr">index</span>: vout,</span><br><span class="line">    <span class="attr">witnessUtxo</span>: &#123;</span><br><span class="line">      <span class="attr">script</span>: <span class="title class_">Buffer</span>.<span class="title function_">from</span>(<span class="string">&#x27;76a914&#x27;</span> + bitcoin.<span class="property">crypto</span>.<span class="title function_">hash160</span>(keyPair.<span class="property">publicKey</span>).<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>) + <span class="string">&#x27;88ac&#x27;</span>, <span class="string">&#x27;hex&#x27;</span>),</span><br><span class="line">      <span class="attr">value</span>: amount,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  psbt.<span class="title function_">addOutput</span>(&#123;</span><br><span class="line">    <span class="attr">address</span>: toAddress,</span><br><span class="line">    <span class="attr">value</span>: amount - <span class="number">10000</span>, <span class="comment">// 扣除手续费</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  psbt.<span class="title function_">signInput</span>(<span class="number">0</span>, keyPair);</span><br><span class="line">  psbt.<span class="title function_">finalizeAllInputs</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tx = psbt.<span class="title function_">extractTransaction</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">json</span>(&#123; <span class="attr">transactionHex</span>: tx.<span class="title function_">toHex</span>() &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="配置前端调用-API-1"><a href="#配置前端调用-API-1" class="headerlink" title="配置前端调用 API"></a>配置前端调用 API</h2><p>在 <code>app/routes/index.tsx</code> 文件中添加一个按钮来调用生成比特币地址的 API：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useLoaderData &#125; <span class="keyword">from</span> <span class="string">&quot;@remix-run/react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; json, <span class="title class_">LoaderFunction</span> &#125; <span class="keyword">from</span> <span class="string">&quot;@remix-run/node&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LoaderData</span> = &#123;</span><br><span class="line">  <span class="attr">address</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">loader</span>: <span class="title class_">LoaderFunction</span> = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;/api/bitcoin&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">  <span class="keyword">return</span> json&lt;<span class="title class_">LoaderData</span>&gt;(&#123; <span class="attr">address</span>: data.<span class="property">address</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Index</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; address &#125; = useLoaderData&lt;<span class="title class_">LoaderData</span>&gt;();</span><br><span class="line">  <span class="keyword">const</span> [transactionHex, setTransactionHex] = <span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">createTransaction</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;/api/bitcoin&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">        <span class="attr">previousTxId</span>: <span class="string">&quot;dummy_previous_tx_id&quot;</span>,</span><br><span class="line">        <span class="attr">vout</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">amount</span>: <span class="number">100000</span>,</span><br><span class="line">        <span class="attr">toAddress</span>: address</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> res.<span class="title function_">json</span>();</span><br><span class="line">    <span class="title function_">setTransactionHex</span>(data.<span class="property">transactionHex</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Generated Bitcoin Address: &#123;address&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;createTransaction&#125;</span>&gt;</span>Create Transaction<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;transactionHex &amp;&amp; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Transaction Hex:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;transactionHex&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动开发环境"><a href="#启动开发环境" class="headerlink" title="启动开发环境"></a>启动开发环境</h2><p>确保一切设置完毕后，可以通过</p><p>以下命令启动开发环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>这样，你就创建了一个 Web 服务，可以生成比特币地址并构建比特币交易。通过 <code>npm run dev</code> 命令可以启动开发环境，并访问 <code>http://localhost:3000</code> 查看效果。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过本文的指南，你已经学会了如何使用 <code>bitcoinjs-lib</code> 的 6.1.5 版本进行比特币开发。从安装 <code>bitcoinjs-lib</code> 到创建比特币地址和构建比特币交易，再到配置前端调用 API 并启动开发环境，我们逐步介绍了每一个步骤。希望这篇指南对你的比特币开发之旅有所帮助。</p><p>如果有任何问题或建议，请随时与我们联系。Happy Coding!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;了解了，&lt;code&gt;bitcoinjs-lib&lt;/code&gt; 的 6.1.5 版本已经移除了 &lt;code&gt;TransactionBuilder&lt;/code&gt;。我们将使用 &lt;code&gt;Psbt&lt;/code&gt; (Partially Signed Bitcoin Transact</summary>
      
    
    
    
    <category term="比特币开发" scheme="https://coiniy2024.github.io/categories/%E6%AF%94%E7%89%B9%E5%B8%81%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="开发入门" scheme="https://coiniy2024.github.io/tags/%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>如何实现比特币的可编程性</title>
    <link href="https://coiniy2024.github.io/post/b26c3cb7.html"/>
    <id>https://coiniy2024.github.io/post/b26c3cb7.html</id>
    <published>2024-06-01T02:11:20.473Z</published>
    <updated>2024-06-01T02:29:11.542Z</updated>
    
    <content type="html"><![CDATA[<p>近期比特币社区里掀起来一波关于重新启用 OP_CAT 等操作码的讨论。Taproot Wizard 也通过推出 Quantum Cats 的 NFT、声称已经获得 BIP-420 的编号等，吸引了不少人的注意力。支持者宣称，启用了 OP_CAT 可以实现「限制条款」（covenants）、实现比特币的智能合约或可编程性。</p><p>如果你注意到「限制条款」这个词并稍作搜索，就会发现这是另一个很大的兔子洞。开发人员已经讨论了多年，除了 OP_CAT 之外，还有 OP_CTV、APO、OP_VAULT 等等实现限制条款的技术。</p><p>那么，究竟什么是比特币的「限制条款」？为什么能吸引到如此多的开发人员持续数年的关注和讨论？能实现比特币的哪些可编程性？背后的设计原理是什么样的？本文试做一个概览性的介绍和讨论。</p><h2 id="什么是「限制条款」"><a href="#什么是「限制条款」" class="headerlink" title="什么是「限制条款」"></a>什么是「限制条款」</h2><p>Covenants，中文译作「限制条款」，有时也翻译为「契约」，是一种能够给未来的比特币交易设置条件的机制。</p><p>当前的比特币脚本也包含了限制的条件，例如花费的时候要输入合法的签名、送入符合的脚本等。但是只要用户能解锁，就可以将该 UTXO 花到任意他希望的地方。</p><p>而限制条款是，在此限制如何解锁的基础之上，做出更多限制，例如限制 UTXO 之后的花费，也就是实现类似「专款专用」的效果；或一笔交易中送入的其他输入条件等。</p><p>更为严谨地说，目前的比特币脚本也具备一定的限制条款，例如基于操作码的时间锁，就是通过内省交易的 nLock 或者 nSequence 字段来实现交易花费前的时间限制，但也基本仅限于时间方面的限制。</p><p>那么，开发和研究人员为什么要设计这些限制检查？因为限制条款不只是为了限制而限制，更是设置了交易执行的规则。这样，用户只能按照预先设定的规则来执行交易，从而完成预定的业务流程。</p><p>所以比较反直觉的是，这可以解锁更多应用场景。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h3 id="确保-Staking-的惩罚"><a href="#确保-Staking-的惩罚" class="headerlink" title="确保 Staking 的惩罚"></a>确保 Staking 的惩罚</h3><p>限制条款的一个最直观的例子是 Babylon 在 Bitcoin staking 流程中的 slash 交易。</p><p>Babylon 的 Bitcoin staking 过程是用户将自己的 BTC 资产在主链上发送到一个特殊的脚本中，花费条件包括两种：</p><ul><li>Happy ending：经过一定的时间后，用户用自己的签名即可解锁，即完成 unstake 的过程</li><li>Bad ending：如果用户在某个被 Babylon 租借安全性的 PoS 链上有双签等作恶行为，那么通过 EOTS（extractable one-time signatures，一次性可提取签名），可以解锁出这部分资产，并由网络中的执行角色将一部分资产强制发送到燃烧地址（slash）</li></ul><p><em>来源：Bitcoin Staking: Unlocking 21M Bitcoins to Secure the Proof-of-Stake Economy</em></p><p>注意这里的「强制发送」，这意味着即便是可以解锁这笔 UTXO，但该资产不能任意地发送到其他任何地方，只能燃烧掉。这样才能保证作恶的用户无法抢先用自己已知的签名把资产转回给自己，以逃脱惩罚。</p><p>这个功能如果在 OP_CTV 等限制条款实现后，可以在 staking 脚本的「bad ending」分支中增加 OP_CTV 等 opcode 以实现限制。</p><p>而在 OP_CTV 启用前，Babylon 就需要通过变通的方法，由用户 + 委员会共同执行的方式来模拟实现限制条款强制执行的效果。</p><h3 id="拥堵控制"><a href="#拥堵控制" class="headerlink" title="拥堵控制"></a>拥堵控制</h3><p>一般而言，拥堵是指当比特币网络上手续费率很高，交易池中积攒了比较多的交易等待打包，所以如果用户想要快速确认交易，就需要提高手续费。</p><p>而此时如果一个用户必须发送多笔交易给多个收款方，就不得不提高手续费，承担比较高的成本。同时也相应的会进一步推高整个网络的手续费率。</p><p>如果有了限制条款，一个解决方法是发送方，可以先承诺到一笔批量发送的交易上。这个承诺可以让所有的接收方相信，最终的交易都会进行，可以等到手续费率低的时候再发送具体的交易即可。</p><p>如下图所示，当对区块空间的需求很高时，进行交易变得非常昂贵。通过使用 OP_CHECKTEMPLATEVERIFY，大批量支付处理商可以将其所有付款聚合到单个 O（1） 事务中以进行确认。然后，一段时间后，当对区块空间的需求减少时，付款可以从该 UTXO 中扩展出来。</p><p><em>来源：<a href="https://utxos.org/uses/scaling/">https://utxos.org/uses/scaling/</a></em></p><p>这个场景是 OP_CTV 这个限制条款提出的比较典型的一个应用案例。还有更多的应用案例可从 <a href="https://utxos.org/uses/">https://utxos.org/uses/</a> 找到，除了上述拥堵控制，该网页列举了 Soft Fork Bets、Decentralized options、Drivechains、Batch Channels、Non Interactive Channels、Trustless Coordination-Free Mining Pools、Vaults、Safer Hashed Time Locked Contracts (HTLCS) Limits 等。</p><h3 id="保管库"><a href="#保管库" class="headerlink" title="保管库"></a>保管库</h3><p>保管库（vault）是比特币应用中一类比较广泛讨论的应用场景，特别是在限制条款领域内。因为日常操作不可避免的要在资金保管与资金使用需求之间进行平衡，所以人们希望能有一类保管金库的应用：可以保证资金安全，甚至即使账户被黑（泄露了私钥），也能限制资金的使用。</p><p>基于实现限制条款的技术，保管库类的应用可以比较容易的构建出来。</p><p>以 OP_VAULT 的设计方案为例：在花费保管库中的资金时，需要先发送一笔交易上链。这笔交易表明了希望花费保管库的意图，即「trigger」，并在其中设置了条件：</p><ul><li>如果一切正常，那么第二笔交易是最终取款的交易。等待 N 个区块后，可以将资金进一步花费到任意地方</li><li>如果发现是这笔交易被窃取的（或者是被「扳手攻击」时候胁迫的），在 N 个区块的取款交易发送前，可以立即发送到另一个安全地址（用户更安全的保管）</li></ul><p><em>OP_VAULT 的流程，来源：BIP-345</em></p><p>需要注意的是，在没有限制条款的情况下，也可以构建出来一个保管库应用，一个可行的办法是用私钥来准备好以后花费的签名，然后销毁掉这个私钥。但限制仍然比较多，例如需要确保这个私钥已经销毁掉（类似于零知识证明中的 trusted setup 过程）、金额和手续费提前确定（因为要预签名）因而缺乏灵活性等。</p><p><em>OP_VAULT 和预签名式的保管库流程对比，来源：BIP-345</em></p><h3 id="更健壮和灵活的状态通道"><a href="#更健壮和灵活的状态通道" class="headerlink" title="更健壮和灵活的状态通道"></a>更健壮和灵活的状态通道</h3><p>一般可以认为，包括闪电网络在内的状态通道拥有和主链近乎等同的安全性（在保证节点可观察最新状态、能够正常发布最新状态上链的情况下）。然而在有了限制条款之后，一些新的状态通道的设计想法可以在闪电网络的之上更加健壮或灵活。这其中比较知名的包括 Eltoo、 Ark 等。</p><p>Eltoo （也称为 LN-Symmetry）就是其中一个比较典型的例子。这个技术方案取「L2」的谐音，为闪电网络提出了一种执行层，允许任何后来的通道状态取代之前的状态，而不需要惩罚机制，因此也可以同时避免类似闪电网络节点那种必须保存多个之前状态以防止对手作恶。为了实现上述效果， Eltoo 提出了 SIGHASH_NOINPUT 的签名方式，即 APO（BIP-118）。</p><p>而 Ark 旨在降低闪电网络的入站流动性和通道管理等难度。它是一种 joinpool 形式的协议，多个用户都可以在一定时间内接受一个服务提供商作为交易对手，在链外进行虚拟 UTXO（vUTXO）的交易，但在链上共享一个 UTXO 从而降低成本。和保管库类似，Ark 也可以在当前的比特币网络上实现；但引入了限制条款之后，Ark 可以基于交易模板降低所需要的交互量，实现更去信任化的单边退出。</p><h2 id="限制条款技术概览"><a href="#限制条款技术概览" class="headerlink" title="限制条款技术概览"></a>限制条款技术概览</h2><p>从上述应用可以看到，限制条款更像一个效果而非某种技术，因此有许多种实现的技术方式。如果进行分类，可以包括：</p><ul><li>类型：通用型、专用型</li><li>实现方式：基于 Opcode、基于签名</li><li>递归：递归、非递归</li></ul><p>而其中，递归是指：有一些限制条款的实现，也可以通过限制下一笔输出来限制再下一笔的输出，可以实现添加的限制可以超越一笔交易，达到更高的交易深度。</p><p>一些主流的限制条款设计包括：</p><p>* 递归：如果结合 OP_CAT </p><h2 id="限制条款的设计"><a href="#限制条款的设计" class="headerlink" title="限制条款的设计"></a>限制条款的设计</h2><p>从前面的介绍可以看出来，目前的比特币脚本主要限制了解锁的条件，没有限制该 UTXO 如何进一步被花费。要实现限制条款，我们就要反过来思考：为什么目前的比特币脚本无法实现限制条款？</p><p>原因主要在于目前的比特币脚本无法读取交易自身的内容，即交易的「内省」（introspection）。</p><p>如果我们可以实现交易的内省——检查交易的任何内容（包括输出），那么就可以实现限制条款了。</p><p>因此限制条款的设计思路也主要围绕在如何实现内省上。</p><h3 id="基于操作码-vs-基于签名"><a href="#基于操作码-vs-基于签名" class="headerlink" title="基于操作码 vs 基于签名"></a>基于操作码 vs 基于签名</h3><p>最简单粗暴的想法是，增加一个或多个操作码（即一个操作码 + 多种参数，或多个不同功能的操作码），直接读取交易的内容。这个也就是基于操作码的思路。</p><p>而另外一种思路是，可以不在脚本中直接读取和检查交易自身的内容，而是可以利用交易内容的哈希——如果已经对这个哈希进行了签名，那么只要在脚本里改造例如 OP_CHECKSIG 等来实现对这个签名的检查，就可以间接的实现交易内省及限制条款了。这个思路就是基于签名的设计方式。主要包括 APO 及 OP_CSFS 等。</p><h3 id="APO"><a href="#APO" class="headerlink" title="APO"></a>APO</h3><p>SIGHASH_ANYPREVOUT（APO）是提议中的一种比特币签名方式。签名的最简单的方式是对交易的输入输出都承诺，但比特币还有更为灵活的方式，即 SIGHASH，选择性地对一笔交易中的输入或输出进行承诺。</p><p><em>目前 SIGHASH 及其组合对交易输入输出的签名范围（来源《Mastering Bitcoin, 2nd》</em></p><p>如上图所示，除了适用到全部数据的 ALL 之外，NONE 的签名方式是只适用到所有输入，而不用于输出；SINGLE 是在此基础上，只对适用到相同输入序号的输出。另外，SIGHASH 还可以组合，叠加了 ANYONECANPAY 修饰符后，只适用于一笔输入。</p><p>而 APO 的 SIGHASH 则是只对输出签名，而不对输入部分签名。这也就意味着，用 APO 方式签名之后的交易，可以在之后附加到任何一个满足条件的 UTXO 上。</p><p>这种灵活性是 APO 实现限制条款的理论基础：</p><ul><li>可以预先创建一笔或多笔交易</li><li>通过这些交易的信息构建出一个只能求出一个签名的公钥</li><li>这样任何发送到该公钥地址上的资产都只能通过预先创建的交易来花费</li></ul><p>值得注意的是，因为这个公钥没有对应的私钥，所以可以确保这些资产只能通过预先创建的交易来花费。那么，我们就可以在预先创建的这些交易中规定资产的去向，从而实现限制条款。</p><p>我们可以进一步通过对比以太坊的智能合约来理解：通过智能合约我们可以实现的也是只有通过一定的条件，才能从合约地址中取款，而非靠一个 EOA 签名就任意花费。从这一点来讲，比特币通过签名机制的改进就可以实现这种效果。</p><p>但上述过程中的问题在于计算时存在循环依赖，因为需要知道输入的内容来预签并创建交易。</p><p>APO 以及 SIGHASH_NOINPUT 实现这种签名方式的意义在于可以解决这种循环依赖问题，在计算时只需要知道（指定）交易的全部输出即可。</p><h3 id="OP-CTV"><a href="#OP-CTV" class="headerlink" title="OP_CTV"></a>OP_CTV</h3><p>OP_CHECKTEMPLATEVERIFY （CTV） ，即 BIP-119 ，采用了改进 Opcode 的方式。它将 commitment hash 作为参数，并要求任何执行操作码的交易都包含一组与该承诺匹配的输出。通过 CTV，将允许比特币用户限制他们使用比特币的方式。</p><p>该提案最初以 OP_CHECKOUTPUTSHASHVERIFY （COSHV） 的名义推出，并且早期侧重于创建拥塞控制交易的能力，因此对该提案的批评也集中在该方案不够通用、过于具体地针对拥塞控制用例。</p><p>在上文提到的拥堵控制用例中，发送者 Alice 可以创建 10 个输出并对这 10 个输出进行哈希，并使用生成的摘要来创建一个包含 COSHV 的 tapleaf 脚本。Alice 还可以使用参与者的公钥来形成 Taproot 内部密钥，以允许他们在不泄露 Taproot 脚本路径的情况下合作支出。</p><p>然后，Alice 会给每个接收者一份所有 10 个输出的副本，以便他们每个人都验证 Alice 的设置交易。当他们以后想要花费这笔付款时，他们中的任何一个都可以创建一个包含承诺输出的交易。</p><p>在整个过程中，在 Alice 创建并发送设置交易时，Alice 可以通过现有的异步通信方法（如电子邮件或云驱动器）发送这 10 个输出副本。这意味着，接收者不需要在线，也不需要相互交互。</p><p><em>来源：<a href="https://bitcoinops.org/en/newsletters/2019/05/29/#proposed-transaction-output-commitments">https://bitcoinops.org/en/newsletters/2019/05/29/#proposed-transaction-output-commitments</a></em></p><p>和 APO 类似，地址也可根据支出条件来构建，可以用不同的方式来制作「锁」，包括：增加其他的 key、时间锁、可组合逻辑。</p><p><em>来源：<a href="https://twitter.com/OwenKemeys/status/1741575353716326835">https://twitter.com/OwenKemeys/status/1741575353716326835</a></em></p><p>CTV 在此基础上提出了可以检查经过 hash 后的花费交易是否与定义的匹配，即将交易数据作为开「锁」的密钥。</p><p>我们可以将上面 10 个接收者的例子继续延伸，接收方可进一步将其地址密钥设置为已签名但未广播的 tx 发送给下一批接收方地址，以此类推，形成一个如下图所示的树状结构。Alice 在链上只用 1 utxo 的区块空间就可以构造一个涉及多个用户的账户余额变更。</p><p><em>来源：<a href="https://twitter.com/OwenKemeys/status/1741575353716326835">https://twitter.com/OwenKemeys/status/1741575353716326835</a></em></p><p>而如果其中一个叶子是闪电通道、是 cold storage、是其他支付路径呢？那么这棵树将从单维多层的支出树扩展至多维多层次的支出树，能支持的场景将更为丰富和灵活。</p><p><em>来源：<a href="https://twitter.com/OwenKemeys/status/1744181234417140076">https://twitter.com/OwenKemeys/status/1744181234417140076</a></em></p><p>CTV 自提出以来，经历了 2019 年从 COSHV 更名、在 2020 年被分配了 BIP-119，并出现用于创建支持 CTV 合约的编程语言 Sapio，在 22、23 年得到了社区很多讨论、更新，以及对其激活方案的争论，目前仍是社区讨论比较多的一个软分叉升级提案之一。</p><h3 id="OP-CAT"><a href="#OP-CAT" class="headerlink" title="OP_CAT"></a>OP_CAT</h3><p>OP_CAT 如开篇所介绍的，也是一个目前非常受关注的升级提案，实现的功能对堆栈中的两个元素进行拼接（concatenante）。虽然看上去很简单，但 OP_CAT 可以很灵活的在脚本中实现很多功能。</p><p>最直接的例子就是对于 merkle 树相关的操作。Merkle 树可以理解为两个元素先拼接，再进行 hash。目前比特币脚本里有 OP_SHA256 等 hash 的操作码，所以如果能用 OP_CAT 实现对两个元素拼接，就可以在脚本中实现 merkle 树的验证功能，也就在一定程度上具备了轻客户端验证的能力。</p><p>另外的实现基础还包括对于 Schnorr 签名的增强：可以对脚本的花费签名条件设置为用户的公钥和公开 nonce 的拼接；之后如果签名者如果想要另签一个交易将这笔资金花费到其他地方，就不得不使用同样的 nonce 而导致私钥泄露。也就是通过 OP_CAT 实现了对 nonce 的承诺，进而确保已签名交易的有效性。</p><p>OP_CAT 的其他的应用场景还包括：Bistream、树形签名、抗量子的 Lamport 签名、保管库等等。</p><p>OP_CAT 本身并不是一个新的功能，它曾在比特币最早期版本中存在过，不过由于可能导致被攻击所利用而在 2010 年开始被禁用。例如，重复使用 OP_DUP 和 OP_CAT 就可以很容易的让全节点在处理此类脚本时堆栈爆炸，参考这个 demo。</p><p>但现在重新启用 OP_CAT 不会发生前面提到的堆栈爆炸问题么？因为当前的 OP_CAT 提案只涉及到在 tapscript 中启用，而 tapscript 限定了每个堆栈元素不超过 520 字节，所以不会产生以前的堆栈爆炸问题。还有一些开发者认为中本聪直接禁用 OP_CAT 可能过于严苛。但由于 OP_CAT 的灵活性，可能确实一些会导致漏洞的应用场景在当前无法穷尽。</p><p>所以综合了应用场景和潜在风险等，OP_CAT 最近受到很多关注，也有过 PR review，是当前最热门的升级提议之一。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>「自律带来自由」，从上面的介绍可以看到，限制条款可以直接在比特币脚本中实现对交易进一步花费的限定，从而实现类似智能合约效果的交易规则。相比于 BitVM 等链外方式，这种编程方式可以更为原生的在比特币上验证，同时也可以改进主链上的应用（拥堵控制）、链外应用（状态通道）以及其他的新的应用方向（staking 惩罚等）。</p><p>限制条款的实现技术如果能再结合一些底层的升级，会进一步释放可编程性的潜力。例如，最近在 <a href="https://bitcoincore.reviews/29221">review</a> 中的 64 位运算符的提案，就可以进一步与提议的 OP_TLUV 或其他的限制条款结合，可以基于交易输出的聪的数量来进行编程。</p><p>但限制条款也可能会导致一些计划外的滥用或漏洞，因此社区对此也比较谨慎。另外，限制条款的升级也需要涉及到共识规则的软分叉升级。鉴于 taproot 升级时的情形，限制条款相关的升级可能也需要假以时日来完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期比特币社区里掀起来一波关于重新启用 OP_CAT 等操作码的讨论。Taproot Wizard 也通过推出 Quantum Cats 的 NFT、声称已经获得 BIP-420 的编号等，吸引了不少人的注意力。支持者宣称，启用了 OP_CAT 可以实现「限制条款」（cov</summary>
      
    
    
    
    <category term="btc" scheme="https://coiniy2024.github.io/categories/btc/"/>
    
    
    <category term="btc" scheme="https://coiniy2024.github.io/tags/btc/"/>
    
  </entry>
  
  <entry>
    <title>avm</title>
    <link href="https://coiniy2024.github.io/post/a927044d.html"/>
    <id>https://coiniy2024.github.io/post/a927044d.html</id>
    <published>2024-06-01T02:11:11.029Z</published>
    <updated>2024-06-01T02:28:56.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AVM白皮书（中文版）-通过模拟比特币虚拟机在比特币上实现智能合约"><a href="#AVM白皮书（中文版）-通过模拟比特币虚拟机在比特币上实现智能合约" class="headerlink" title="AVM白皮书（中文版）: 通过模拟比特币虚拟机在比特币上实现智能合约"></a><strong>AVM白皮书（中文版）</strong>: 通过模拟比特币虚拟机在比特币上实现智能合约</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a><strong>摘要</strong></h3><p>到目前为止，比特币上所有的叠加数字资产协议均依照固定规则来创建和转移数字资产。通过允许程序员定义状态机逻辑来创建和管理这些规则，我们可以为叠加数字资产制定完全灵活的（图灵完备的）智能合约。我们提出了一种解决方案，将比特币作为全球数据库使用，将智能合约代码存储在交易中，并在沙盒环境中通过叠加数字资产索引器执行这些代码。原始比特币脚本操作码指令集被采用作为编程语言，因其具备在资源有限的环境中高效执行的所有必要属性。状态哈希用来追踪叠加交易，并为参与者提供一种方便的方式来验证他们的同步状态。我们提出的这个解决方案是比特币叠加数字资产协议自然演进的一步，同时也是测试原始比特币操作码的平台，展示其灵活性和安全性。</p><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a><strong>1. 引言</strong></h2><p>比特币点对点电子现金系统[1]最初主要被用作价值存储，因此被称为“数字黄金”，而作为交换媒介的功能则较为次要。在中本聪离开之前，他出于安全考虑，特别是为了避免潜在的拒绝服务攻击，禁用了许多用于高级脚本编写的原始操作码（Op Codes）。这些被禁用的操作码主要包括算术和二进制操作，这些都是开发人员在最基本的编程环境中所依赖的基础操作。没有这些关键操作码的支持，比特币的应用开发人员和最终用户的可用功能非常有限。特别是“OP_CAT”（数据连接）操作码，它本可以用来创建自定义的消费和转移约束，即所谓的契约。因此，由于这些历史性的决策，比特币未能成为中本聪最初设想的强大智能合约平台，而只能作为一种数字黄金存在。简而言之，由于这些关键操作码的禁用，比特币不得不仅仅作为数字黄金存在，无法发展成完整的智能合约系统，以此来保护这个新兴的电子现金系统。</p><blockquote><p>“比特币的本质在于，一旦0.1版本被发布，其核心设计便在其生命周期内被固定下来。正因如此，我打算设计它能够支持我能想到的所有交易类型。问题是，每一种交易类型都需要特别的支持代码和数据字段，不管这些是否被使用，每次只能处理一种特定情形。这就可能导致特殊情形的过多膨胀。脚本提供了一种解决方案，它将问题进行泛化，使得交易双方可以将他们的交易描述为一个由节点网络来评估的谓词。” ——中本聪[2]</p></blockquote><p>自从比特币首次禁用部分操作码以来，已引入了多种保护措施。其中一个重要的限制是 MAX_SIGOPS，它限制了任何特定交易中允许的最大签名操作次数。通过回顾历史，我们可以观察到这些原始操作码在比特币的分叉版本如BCH和BSV中的表现；这些分叉几年前重新激活了大多数原始操作码。到目前为止，这些操作码并未引发任何安全问题或拒绝服务攻击，也几乎没有引起任何争议。相反，它们极大地拓展了这些比特币分叉的开发潜力。</p><p>尽管比特币智能合约目前存在限制，但已经出现了一些允许在比特币本身上创建和转移数字资产的叠加协议。第一个主流的非同质化代币标准是称为Ordinals的协议，紧接着推出了一种同质化代币标准BRC20。此后不久，涌现出了更多其他数字资产协议，例如Atomicals数字对象和ARC20，后者利用satoshi单位作为账户单位，以及Bitcoin Stamp和最近的Runes同质化代币协议（2024年4月发布）。这一代叠加协议基本上通过比特币交易来创建和管理数字资产，而叠加协议索引器则通过直接从特殊的比特币交易中读取数据来追踪和管理数字资产的生命周期。这些协议中缺少的是开发人员自定义数字资产行为的能力——直到现在，还没有一种方法能为这些叠加协议创造高级智能合约。</p><p>我们提出了一种通过模拟比特币虚拟机及其脚本解释器来为各类叠加数字资产创建和执行智能合约的方法。在这种方法中，比特币区块链不仅为链上存储的智能合约程序提供时间戳和数据，同时，这些程序的执行也通过各种叠加协议索引器在一个沙盒环境中进行。叠加协议索引器节点由应用程序开发者、服务提供者和用户共同管理，共同形成了一种自发的共识。这一概念及其技术可广泛适用于所有叠加协议，只需要针对各自的叠加协议索引器作适当调整即可。</p><p>我们展示了原始比特币设计的力量与优雅。这种新的范式可作为测试各种操作码的平台——尽管它是针对数字资产叠加协议的——我们希望比特币最终能够重新启用所有原始操作码，从而释放中本聪创造的最大潜力。</p><h3 id="2-比特币作为全球数据库"><a href="#2-比特币作为全球数据库" class="headerlink" title="2. 比特币作为全球数据库"></a><strong>2. 比特币作为全球数据库</strong></h3><p>比特币网络本质上是为解决双重支付问题而设计的分布式时间戳服务器。系统的设计不仅适用于货币交易的传输和存储，还可以用于存储发票、大型文件等数据。中本聪包括了各种操作码，如OP_RETURN，允许附加任意数据，以及OP_PUSHDATA4，允许数据推送高达4GB。甚至第一笔比特币交易——创世币基交易——也包括了任意文本数据：“The Times 03&#x2F;Jan&#x2F;2009 Chancellor on brink of second bailout for banks”。</p><p>多年来，人们一再尝试通过将最大推送大小限制为520字节，并将OP_RETURN的使用限制在40字节（后来扩展到80字节）来阻止比特币被用作数据存储介质。确实，这曾被视为一种可能导致“区块链膨胀”失控、挤占纯货币用途的攻击向量。这在当时看似是一种合理的保护措施。</p><p>近年来，比特币开发者通过引入隔离见证（SegWit）和Taproot升级，有效地重新引入了早期比特币版本类似的大量任意数据存储能力。应用开发者迅速利用这一机会，利用比特币作为不可变的全球账本来存储有价值的数据。比特币上的数字资产市场呈现出指数级增长，市值达到数十亿美元，并在相对较短的时间内为矿工创造了数亿美元的网络费用。</p><h3 id="3-叠加协议"><a href="#3-叠加协议" class="headerlink" title="3. 叠加协议"></a><strong>3. 叠加协议</strong></h3><p>哈尔·芬尼（Hal Finney）提出并预测了利用比特币作为全球化、去中心化、一致性数据库来支持“叠加其他协议”的概念。这一基本思想涉及到通过信号传递来创建叠加资产，并将这些资产与特定的交易历史相关联。这一机制为比特币作为货币系统增添了新的维度，即交易输出本身可以代表任何其他类型的数字资产，如代币、积分、数字媒体，甚至是物理资产的代理权。</p><blockquote><p>“在BitDNS线程的讨论中，我提出了一个将其他协议叠加到比特币上的想法。从某种角度来看，比特币是一个全球性的、去中心化的、但又保持一致性的数据库。</p><p>这个数据库主要用于记录硬币的转移，但它也可以用于更多其他用途。许多应用程序可以从一个全球一致的数据库中受益。根据我对BitDNS的描述，这一机制将通过使用一种神秘且复杂的“脚本”系统向常规比特币交易中添加额外的数据来实现。这些数据对当前的客户端而言会显示为NOP（无操作指令）并被忽略，但是叠加协议感知的客户端会检查这些NOP块内的额外数据，并根据叠加协议进行解释。</p><p>具体来说，我可以想象使用OP_NOP1来标记叠加数据，然后使用OP_PUSHDATA来推送特定数据，接着使用OP_DROP将数据从栈中移除，最后执行常规的交易操作码。这对常规客户端没有任何影响，看起来就像是一笔普通的交易（可以是一笔虚拟交易，例如自己转给自己0.01比特币），但是能够识别叠加协议的代码会识别出这是一笔协议交易。</p><p>例如，比特币可以用作一种廉价的时间戳服务，允许您证明某个文档在某个特定日期之前已经存在。您需要做的只是创建一笔虚拟交易给自己，并修改客户端来执行一个OP_PUSHDATA操作，将文档的哈希值推送进去，然后用OP_DROP将其从栈中移除。这个哈希值将永久存在于区块链中，并作为该文档在那个日期存在的证据。” ——哈尔·芬尼[3]</p></blockquote><p>首个获得广泛应用的叠加协议是Ordinals理论。根据Ordinals手册的描述，单个satoshi可以刻录任意内容，创建出独特的比特币原生数字工件。这些工件既耐用、不可变、安全，又去中心化，可以保存在比特币钱包中，并通过比特币交易进行转移。</p><p>紧随其后的2023年，开发者们认识到比特币上需要一个同质化代币标准，于是便开发出了BRC20。BRC20借助Ordinals理论建立了一个与钱包地址相关联的叠加账户模型，使其能够发送和接收代币单位，实际上是在Ordinals的基础上创建了一个分层的叠加协议，而Ordinals本身就是一种基于比特币的叠加协议。</p><p>到了2024年初，又出现了一个名为Atomicals协议数字对象的新协议，以应对代币标准和索引技术市场的持续增长。如Atomicals指南所述，Atomicals协议是一个简单但灵活的协议，适用于在使用未花费交易输出（UTXO）的区块链（如比特币）上铸造、转移和更新数字对象（通常称为非同质化代币）。Atomical（或“原子”）是按照一些简单规则组织数字所有权链的方式。Atomicals协议还包括了一个名为ARC20的同质化代币标准，每个代币单位至少由一个satoshi单位支持，并且使用与比特币本身同样的UTXO架构操作。</p><p>2024年稍晚时候，另一个名为Runes的叠加协议被发布，它直接在Ordinals索引器中实施，以完善Ordinals理论的功能，最终也包括了一个同质化代币标准。</p><h3 id="4-状态机"><a href="#4-状态机" class="headerlink" title="4. 状态机"></a><strong>4. 状态机</strong></h3><p>到目前为止，比特币上所有的叠加协议都是基于固定或预定义的状态机运行的。这些叠加协议共有两个主要组成部分：一是负责信号传递以创建数字资产，二是管理这些数字资产转移的规则。这些状态机规则被硬编码在各自的叠加协议索引器中，开发者无法自定义创建或转移规则。</p><p>我们提出了一种动态的状态机编程模型，允许开发者完全自主地定义其数字资产的创建和转移规则。这本质上使开发者能够定义自己的元叠加协议规则，而无需创建新的协议索引器，而是可以利用现有的叠加协议索引器。</p><p><img src="https://docs.wizz.cash/~gitbook/image?url=https://2889738779-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%252FldTGMAu85aOIfm3hoGzh%252Fuploads%252F6n8MRAhNJdusBFwZGfBb%252Fimage.png?alt=media&token=5a7c3bb0-1980-44be-90bf-004dc016f94f&width=768&dpr=4&quality=100&sign=3ebb62a2903d768eddf82856e6b2d7c3e2dff8409c86cb93689ebf9a391dfc8c">基本思想是允许开发者将其智能合约代码存储在区块链上，使所有参与方都可以读取和解释。通过将代码存储在链上，可以确保在分布式且不相连的各方中以相同的方式执行逻辑，从而方便状态的同步。智能合约编程语言应具备以下几个重要属性：</p><ul><li><p>确定性和可预测的运行时间。</p></li><li><p>允许任意的灵活性（图灵完备性）[4]。</p></li><li><p>以及能在资源受限的系统上高效运行。</p></li></ul><p>从这些要求可以看出，比特币脚本非常适合用作定义数字资产创建和转移规则的指令集。关键在于它需要支持任何类型的状态转换，同时限制执行时间以防止服务拒绝攻击和程序无限循环。比特币脚本是图灵完备的，它是一个双栈下推自动机（2-Stack PDA），由于使用了循环展开技术，不允许循环，因此具有运行时间可预测且与程序长度成线性关系的特点。</p><p><img src="https://docs.wizz.cash/~gitbook/image?url=https://2889738779-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%252FldTGMAu85aOIfm3hoGzh%252Fuploads%252FqMzN37PN54ntgHoxFeve%252Fimage-1.png?alt=media&token=7b1bbcfd-64ed-43d3-9793-885cae9c2e54&width=768&dpr=4&quality=100&sign=cf32f94b34908147ddc8ac86c903ecd9ecace0f931924ec9536f2b9df2d368ef">智能合约程序代码被存储在比特币交易中，叠加协议索引器将代码加载到内存中并一致地执行。所有相关方可以执行相同的逻辑，并达到相同的状态转换。</p><h3 id="5-状态共识"><a href="#5-状态共识" class="headerlink" title="5. 状态共识"></a><strong>5. 状态共识</strong></h3><p>状态的同步可以通过状态哈希（statehash）实现，这一机制将叠加协议索引器的内部状态传递给外部观察者。通过公开状态哈希，分布式的各方可以轻松判断他们是否遵循相同的规则并且是否彼此同步。</p><p><img src="https://docs.wizz.cash/~gitbook/image?url=https://2889738779-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%252FldTGMAu85aOIfm3hoGzh%252Fuploads%252FlZIIYcA96QrHcncDI3Rh%252Fimage-2.png?alt=media&token=f93f0eed-e144-4618-b9c7-d26723edbb6f&width=768&dpr=4&quality=100&sign=66c614b21d090e097bde49a304397e61282673cc328c55172a82249b613c809d">由于所有数据都存储在链上并按时间顺序加上时间戳，因此不需要复杂的状态承诺同步机制。这使得任何人都可以在遵循相同规则的前提下，得出一致的状态结果。</p><h3 id="6-虚拟数字资产"><a href="#6-虚拟数字资产" class="headerlink" title="6. 虚拟数字资产"></a><strong>6. 虚拟数字资产</strong></h3><p>任何叠加协议都可以采用这种动态状态机编程技术，允许数字资产在智能合约中进行虚拟化和实体化。本质上，这意味着我们可以将存款和提款的概念视为一种约定，因为其他所有事物都是基于区块链上完整的交易历史记录来构建索引器状态的约定。</p><p>在BRC20中，代币余额是账户的抽象表示，可以被描述为一种虚拟数字资产——即在另一种数字资产（比特币）之上的数字资产。Atomicals ARC20代币是保持与底层satoshi单位的亲和力的抽象，但它们同样也是一种虚拟数字资产。更准确地说，它们被称为“虚拟数字资产”，因为它们的存在是在另一种数字资产（比特币）之上的一个抽象。</p><p>为了创建虚拟的基于账户的抽象层，我们可以定义一个状态机，它允许接受任何类型的代币存入合约，并且之后可以取出，类似于以太坊区块链的Solidity编程语言允许方法被标注为可支付（payable），表示可以向该方法支付以太币，并根据智能合约程序的规则之后取回。这些数字资产的跟踪和管理可以通过特殊的操作码，如OP_FT_WITHDRAW和OP_NFT_WITHDRAW，以及一个允许智能合约状态中的可支付方法接受代币的机制来完成。</p><p>基于账户的抽象化构建，我们可以定义一种受保护的智能合约内存，只能由合约本身写入。回想一下，Atomicals 数字对象已经提供了用于非同质代币的通用键值存储，我们可以定义一个只能通过特殊的键值存取操作码如OP_KV_GET、OP_KV_EXISTS、OP_KV_DELETE和OP_KV_PUT来进行检索、确认存在、删除和写入的内存空间。这种存储技术使得比特币上的智能合约在功能上与以太坊区块链相当。</p><p>我们提出了一种全新的架构方法，称为虚拟UTXO（vUTXO）架构。该架构严格遵循交易输出的消费链条，通过将每个输出与一个特定的锁定脚本绑定，这些锁定脚本只能通过提供相应的有效解锁脚本来解锁。这一机制在覆盖协议的索引器中创建了一个虚拟的UTXO集，从而为虚拟数字资产的开发者摆脱了比特币矿工提供的有限指令集的约束，赋予了极大的自由度。然而，关键的挑战是必须设置有效的过期时间、更新策略和清理策略，以处理过时的vUTXO，防止覆盖协议索引器的状态膨胀过大。</p><h3 id="7-系统架构"><a href="#7-系统架构" class="headerlink" title="7. 系统架构"></a><strong>7. 系统架构</strong></h3><p>为确保脚本的一致性执行，脚本解释器被设置在一个具有静态或动态绑定、边界明确的沙盒环境中。这种设置使得不同的编程语言和环境能够调用沙盒并获得一致的结果，从而确保执行的一致性。</p><p>沙盒解释器是一个简化版的比特币脚本解释器，它在一些关键方面有所不同，例如它可以直接接受执行锁定脚本（scriptPubKey）和解锁脚本参数（scriptSig），以及其他一些有助于虚拟数字资产管理的有用参数。这些设计的目的是简化和加强虚拟数字资产的处理和管理，使得它们可以更高效、更安全地在比特币网络上操作。</p><p><img src="https://docs.wizz.cash/~gitbook/image?url=https://2889738779-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%252FldTGMAu85aOIfm3hoGzh%252Fuploads%252F3j4P4G8lQ3brT4Ic3sz1%252Fimage-3.png?alt=media&token=a81e0930-f12f-4dd5-b2c7-eda50dd57f01&width=768&dpr=4&quality=100&sign=e2da3afe55247c9b669be613e464e2c320e6bbd786c88a848544abf57082ed1f">### <strong>8. 结论</strong></p><p>我们提出了一种系统，通过模拟比特币虚拟机来在比特币上实现叠加数字资产的智能合约。迄今为止，比特币上的叠加数字资产完全受制于预定义的状态转换规则，这些规则只允许这些资产的创建和转移。为了解决这个局限性，我们开发了一种通用技术，将比特币作为全球数据库，将智能合约代码存储在交易中，并在叠加数字资产索引器的沙盒运行时环境中执行这些代码。</p><p>原始的比特币脚本指令集非常强大，因为它实现了一个双栈下推自动机（2-Stack PDA），已被证明具有图灵完备性。我们的系统使用状态哈希，使得所有参与者都可以轻松地验证他们的索引器状态是否正确地同步。这个系统的设计非常灵活，不仅是现有叠加协议的自然扩展，还展示了原始比特币脚本语言的巨大潜力。这种方法为比特币生态系统内的叠加协议提供了更高级的功能，使其能够支持更复杂的智能合约应用。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;AVM白皮书（中文版）-通过模拟比特币虚拟机在比特币上实现智能合约&quot;&gt;&lt;a href=&quot;#AVM白皮书（中文版）-通过模拟比特币虚拟机在比特币上实现智能合约&quot; class=&quot;headerlink&quot; title=&quot;AVM白皮书（中文版）: 通过模拟比特币虚拟机在比特</summary>
      
    
    
    
    <category term="btc" scheme="https://coiniy2024.github.io/categories/btc/"/>
    
    
    <category term="btc" scheme="https://coiniy2024.github.io/tags/btc/"/>
    
  </entry>
  
  <entry>
    <title>math</title>
    <link href="https://coiniy2024.github.io/post/a927044d.html"/>
    <id>https://coiniy2024.github.io/post/a927044d.html</id>
    <published>2024-06-01T01:58:50.636Z</published>
    <updated>2024-06-01T02:00:59.582Z</updated>
    
    <content type="html"><![CDATA[<p>如 $\lim_{x \to 0} \frac{\sin x}{x}$ 渲染的是</p><p>$$<br>\begin{eqnarray}<br> \lim_{x \to 0} \frac{\sin x + x^2 + x^3}{x} &amp; &#x3D; &amp; \lim_{x \to 0} \frac{\sin x }{x} + \lim_{x \to 0} \frac{x^2 }{x} + \lim_{x \to 0}\frac{x^3}{x}<br>\\ &amp; &#x3D; &amp; \lim_{x \to 0}\frac{\sin x}{x}<br>\\ &amp; &#x3D; &amp; 1<br>\end{eqnarray}<br>$$</p><span id="more"></span><p>斐波那契数列$A_n&#x3D;A_{n-1}+A_{n-2}$,前后两项的比值逐渐收敛到黄金分割比例<br>$$\lim_{n\to \infty}\frac{A_{n-1}}{A_n}&#x3D;\frac{\sqrt{5}-1}{2}.$$</p><p>因式分解<br>$$\begin{split}(x−1)(x−3)&amp;&#x3D;x^2−4x+3 \<br>&amp;&#x3D;x^2−4x+4−1 \<br>&amp;&#x3D;(x−2)^2−1<br>\end{split}<br>$$</p><p>狄利克雷函数</p><p>$$<br>D(x)&#x3D;<br>\begin{cases}<br>1,&amp; x \in Q \<br>0,&amp; x \notin Q<br>\end{cases}<br>$$</p><p>高斯公式<br>$$<br>\iiint_{\Omega}\left(\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}\right) d v&#x3D;\iint_{\Sigma} P d y d z+Q d z d x+R d x d y<br>$$</p><h2 id="物理公式"><a href="#物理公式" class="headerlink" title="物理公式"></a>物理公式</h2><ul><li>牛顿第一定律: $\sum \vec{F}_{i}&#x3D;\frac{\mathrm{d} \vec{v}}{\mathrm{d} t}&#x3D;0$</li><li>牛顿第二定律: $\vec{F}&#x3D;\frac{\mathrm{d} m}{\mathrm{d} t} \vec{v}+m \frac{\mathrm{d} \vec{v}}{\mathrm{d} t}&#x3D;\frac{\mathrm{d} m}{\mathrm{d} t} \vec{v}+m \vec{a}&#x3D;\frac{\mathrm{d} m}{\mathrm{d} t} \vec{v}+m \frac{\mathrm{d}^{2} \vec{r}}{\mathrm{d} t^{2}}$</li><li>牛顿第三定律: $\overrightarrow{F_{12}}&#x3D;-\overrightarrow{F_{21}}$</li><li>质能守恒: $E&#x3D;mc^2$</li></ul><h2 id="化学公式"><a href="#化学公式" class="headerlink" title="化学公式"></a>化学公式</h2><p>离子反应与沉淀: $\ce{SO4^2- + Ba^2+ -&gt; BaSO4 v}$</p><h2 id="生物公式"><a href="#生物公式" class="headerlink" title="生物公式"></a>生物公式</h2><p>光合作用<br>范德蒙行列式<br>$$D_{n-1}&#x3D;\left|\begin{array}{cccc}<br>1 &amp; 1 &amp; \dots &amp; 1 \<br>x_{2} &amp; x_{3} &amp; \dots &amp; x_{n} \<br>\vdots &amp; \vdots &amp; &amp; \vdots \<br>x_{2}^{n-2} &amp; x_{3}^{n-2} &amp; \dots &amp; x_{n}^{n-2}<br>\end{array}\right|&#x3D;\prod_{2 \leq j&lt;i \leq n}\left(x_{i}-x_{j}\right)$$</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如 $&#92;lim_{x &#92;to 0} &#92;frac{&#92;sin x}{x}$ 渲染的是&lt;/p&gt;
&lt;p&gt;$$&lt;br&gt;&#92;begin{eqnarray}&lt;br&gt; &#92;lim_{x &#92;to 0} &#92;frac{&#92;sin x + x^2 + x^3}{x} &amp;amp; &amp;#x3D; &amp;amp; &#92;lim_{x &#92;to 0} &#92;frac{&#92;sin x }{x} + &#92;lim_{x &#92;to 0} &#92;frac{x^2 }{x} + &#92;lim_{x &#92;to 0}&#92;frac{x^3}{x}&lt;br&gt;&#92;&#92; &amp;amp; &amp;#x3D; &amp;amp; &#92;lim_{x &#92;to 0}&#92;frac{&#92;sin x}{x}&lt;br&gt;&#92;&#92; &amp;amp; &amp;#x3D; &amp;amp; 1&lt;br&gt;&#92;end{eqnarray}&lt;br&gt;$$&lt;/p&gt;</summary>
    
    
    
    <category term="math" scheme="https://coiniy2024.github.io/categories/math/"/>
    
    
    <category term="math" scheme="https://coiniy2024.github.io/tags/math/"/>
    
  </entry>
  
</feed>
